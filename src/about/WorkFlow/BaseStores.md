# Техническое задание: Архитектура хранилищ (Stores) 

## 1. Введение

### 1.1 Цель документа
Данный документ описывает архитектуру хранилищ (Stores) для приложения семейного финансового учета на Vue 3 с использованием Pinia. Особое внимание уделяется проектированию структуры данных, связанных с физическими лицами (Person) и их специализациями.

### 1.2 Область применения
Техническое задание распространяется на все модули приложения, использующие централизованное хранение состояния. Особенно актуально для модулей, работающих с учетом персон, категорий, счетов, транзакций и долговых обязательств.

### 1.3 Используемые технологии
- Vue 3
- TypeScript
- Pinia (хранилище состояния)
- Naive UI (компонентная библиотека)

## 2. Общая архитектура хранилищ

### 2.1 Структура каталогов

```
src/
└── stores/
    ├── index.ts            // Точка входа для всех хранилищ
    ├── common/             // Общие типы и утилиты
    │   └── types.ts        // Базовые интерфейсы
    ├── person/             // Базовое хранилище для всех персон
    │   ├── types.ts        // Типы персон
    │   ├── defaultData.ts  // Предустановленные данные
    │   ├── personService.ts// Сервисный слой для работы с персонами
    │   ├── personStore.ts  // Pinia store для персон
    │   └── index.ts        // Экспорты модуля
    ├── user/               // Пользователи системы (аутентификация)
    │   ├── types.ts        
    │   ├── userService.ts  
    │   ├── userStore.ts    
    │   └── index.ts        
    ├── owner/              // Владельцы финансов
    ├── category/           // Категории доходов/расходов
    ├── account/            // Финансовые счета
    ├── book/               // Книги учета
    ├── transaction/        // Транзакции
    └── debt/               // Долги и обязательства
```

### 2.2 Общие принципы организации хранилищ

Каждое хранилище должно придерживаться следующей структуры:

1. **types.ts** - интерфейсы и типы данных
2. **defaultData.ts** - предустановленные данные (если необходимо)
3. **[name]Service.ts** - сервисный слой для бизнес-логики
4. **[name]Store.ts** - хранилище Pinia для управления состоянием
5. **index.ts** - экспорты для удобного импорта

### 2.3 Взаимодействие между хранилищами

- Предпочтительно использовать инъекцию зависимостей через getters
- Избегать циклических зависимостей
- Использовать слабое связывание через ID объектов


### 4.4 Хранилище транзакций (Transaction)

**Расположение**: `src/stores/transaction/types.ts` (пример интерфейсов)

```typescript
export interface Transaction {
  id: string;
  date: Date;
  amount: number;
  currency: string;
  type: TransactionType;
  description?: string;
  categoryId: string;
  
  // Источник транзакции
  sourceEntityId: string;  // ID счета/актива, откуда идет транзакция
  sourceEntityType: string;  // Тип источника
  
  // Назначение (для переводов)
  destinationEntityId?: string;
  destinationEntityType?: string;
  
  // Владелец и распределение
  executedByOwnerId: string;  // Кто выполнил транзакцию
  responsibleOwnerIds: string[];  // Кто отвечает за транзакцию
  distributionRules?: DistributionRule[];  // Распределение
  
  // Книга учета
  bookId: string;
  
  // Метаданные
  tags?: string[];
  attachments?: string[];
  createdAt: Date;
  updatedAt: Date;
}

export type TransactionType = 'income' | 'expense' | 'transfer';
```

### 4.5 Хранилище долгов и обязательств (Debt)

**Расположение**: `src/stores/debt/types.ts` (пример интерфейсов)

```typescript
export interface Debt {
  id: string;
  name: string;
  description?: string;
  type: 'borrowed' | 'lent';  // Взятый или данный долг
  
  // Связь с другими сущностями
  bookId: string;
  assetId?: string;
  passiveId?: string;
  
  // Участники
  ownerIds: string[];  // Кто отвечает за долг
  distributionRules?: DistributionRule[];
  externalPartyId?: string;  // ID внешнего контакта
  
  // Финансовые параметры
  initialAmount: number;
  currentAmount: number;
  currency: string;
  interestRate?: number;
  
  // Временные рамки
  startDate: Date;
  plannedEndDate?: Date;
  actualEndDate?: Date;
  
  // История платежей
  payments: DebtPayment[];
  
  // Статус
  status: DebtStatus;
  
  // Метаданные
  createdAt: Date;
  updatedAt: Date;
  attachments?: string[];
  tags?: string[];
}

export type DebtStatus = 'active' | 'fully_paid' | 'partially_paid' | 'defaulted' | 'cancelled';

export interface DebtPayment {
  id: string;
  debtId: string;
  transactionId: string;
  date: Date;
  amount: number;
  currency: string;
  type: 'principal' | 'interest' | 'fee' | 'penalty' | 'combined';
  breakdown?: {
    principal: number;
    interest: number;
    fee?: number;
    penalty?: number;
  };
  note?: string;
}
```

## 5. Миграция и переходный период

### 5.1 План миграции

1. Создать новую структуру директорий для хранилищ
2. Реализовать общие типы (src/stores/common/types.ts)
3. Реализовать хранилище для Person
4. Последовательно реализовать специализированные хранилища (User, Owner и т.д.)
5. Интегрировать новые хранилища с существующими компонентами

### 5.2 Приоритеты внедрения

1. Хранилище Person (базовое)
2. Хранилища User и Owner
3. Хранилище Account
4. Хранилище Book
5. Хранилище Transaction
6. Хранилище Debt

### 5.3 Поддержка обратной совместимости

В переходный период необходимо обеспечить обратную совместимость с существующим кодом:

1. Создать адаптеры для старых интерфейсов
2. Обеспечить перенаправление вызовов из старых файлов в новые хранилища
3. Пометить старые файлы как устаревшие (deprecated)

## 6. Требования к реализации

### 6.1 Общие требования

1. Строгая типизация (TypeScript)
2. Документирование методов и интерфейсов
3. Использование иммутабельного подхода при работе с данными
4. Обработка всех потенциальных ошибок
5. Соблюдение принципов SOLID

### 6.2 Требования к производительности

1. Оптимизация запросов и обновлений состояния
2. Минимизация ненужных перерендерингов компонентов
3. Использование компьютируемых свойств для кеширования результатов

### 6.3 Требования к тестированию

1. Модульные тесты для сервисных слоев (coverage > 80%)
2. Тесты хранилищ Pinia
3. Интеграционные тесты для взаимодействия между хранилищами

## 7. Заключение

Предложенная архитектура хранилищ обеспечивает гибкую и масштабируемую основу для приложения семейного финансового учета. Особое внимание уделено проектированию сущностей, связанных с физическими лицами (персонами), что позволяет эффективно работать с различными ролями и взаимоотношениями между участниками финансовых операций.

Внедрение данной архитектуры повысит модульность приложения, упростит тестирование и обеспечит четкое разделение ответственности между различными аспектами бизнес-логики.